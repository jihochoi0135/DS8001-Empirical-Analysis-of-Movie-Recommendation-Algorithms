# -*- coding: utf-8 -*-
"""User-based.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1wDfYEze42NiEjkzJVb4wQ5q3V31lsw7_
"""

import os
import pandas as pd
import numpy as np
import time
import random

# Step 0: Same pre-procedure for every algorithms

def rmse(y_true, y_pred):
    y_true = np.asarray(y_true, dtype=float)
    y_pred = np.asarray(y_pred, dtype=float)
    return np.sqrt(np.mean((y_true - y_pred) ** 2))


def split_train_test(df, test_ratio=0.2, seed=42):
    df_shuffled = df.sample(frac=1.0, random_state=seed).reset_index(drop=True)
    n_test = int(len(df) * test_ratio)

    test = df_shuffled.iloc[:n_test].copy()
    train = df_shuffled.iloc[n_test:].copy()

    mask = test["movieId"].isin(train["movieId"]) & test["userId"].isin(train["userId"])
    test = test[mask].reset_index(drop=True)

    return train, test


def evaluate_model(df, predict_fn, test_ratio=0.2, seed=42):
    start_time = time.time()
    train, test = split_train_test(df, test_ratio=test_ratio, seed=seed)
    y_true = test["rating"].values
    y_pred = predict_fn(train, test)
    rmse_score = rmse(y_true, y_pred)
    elapsed = time.time() - start_time
    return rmse_score, elapsed, train, test, y_pred

# User-based
def predict_user_based(train, test, k=30):

    # mapped userId and movieId with their index
    user_ids = train["userId"].unique()
    item_ids = train["movieId"].unique()

    user2idx = {u: idx for idx, u in enumerate(user_ids)}
    item2idx = {m: idx for idx, m in enumerate(item_ids)}

    n_users = len(user_ids)
    n_items = len(item_ids)

    # user-item rates rows (train set)
    R = np.full((n_users, n_items), np.nan, dtype=float)

    for row in train.itertuples(index=False):
        u = user2idx[row.userId]
        i = item2idx[row.movieId]
        R[u, i] = row.rating

    # user-mean and get difference
    global_mean = np.nanmean(R)
    user_mean = np.nanmean(R, axis=1)
    user_mean = np.where(np.isnan(user_mean), global_mean, user_mean)

    R_diff = R - user_mean[:, None]
    R_diff = np.nan_to_num(R_diff, nan=0.0)

    # cosine similarity for user-user
    user_norms = np.linalg.norm(R_diff, axis=1)
    user_norms[user_norms == 0] = 1e-8

    sim_matrix = R_diff @ R_diff.T
    sim_matrix = sim_matrix / (user_norms[:, None] * user_norms[None, :])
    np.fill_diagonal(sim_matrix, 0.0)

    # Prediction function for individual (userId, movieId)
    def predict_single(user_id, movie_id):
        if user_id not in user2idx or movie_id not in item2idx:
            return float(global_mean)

        u_idx = user2idx[user_id]
        i_idx = item2idx[movie_id]

        # users who rated on this item
        users_rated = ~np.isnan(R[:, i_idx])
        if not np.any(users_rated):
            return float(user_mean[u_idx]) if not np.isnan(user_mean[u_idx]) else float(global_mean)

        sims = sim_matrix[u_idx, :].copy()
        sims[~users_rated] = 0.0

        if np.all(sims == 0):
            return float(user_mean[u_idx]) if not np.isnan(user_mean[u_idx]) else float(global_mean)

        # Top-K
        neighbor_idx = np.argsort(-np.abs(sims))[:k]
        neighbor_sims = sims[neighbor_idx]

        neighbor_ratings = R[neighbor_idx, i_idx]
        neighbor_means   = user_mean[neighbor_idx]

        dev = neighbor_ratings - neighbor_means
        mask = ~np.isnan(dev)

        if not np.any(mask):
            return float(user_mean[u_idx]) if not np.isnan(user_mean[u_idx]) else float(global_mean)

        neighbor_sims = neighbor_sims[mask]
        dev = dev[mask]

        denom = np.sum(np.abs(neighbor_sims))
        if denom == 0:
            return float(user_mean[u_idx]) if not np.isnan(user_mean[u_idx]) else float(global_mean)

        pred = user_mean[u_idx] + np.sum(neighbor_sims * dev) / denom
        return float(pred)

    # predicts on whole test dataframe
    preds = []
    for row in test.itertuples(index=False):
        preds.append(predict_single(row.userId, row.movieId))

    return np.array(preds, dtype=float)




#==small
os.chdir(r"C:/Users/Jason/OneDrive/TMU/Fall 25/DS8001/Project/ml-latest-small")
df = pd.read_csv("Master_small.csv")
seed = random.randint(1, 10_000_000)
rmse_val, time_taken,_,_,_ = evaluate_model(df,predict_user_based,0.2,seed)
print(f"user Small: RMSE={rmse_val:.4f}, time={time_taken:.4f}s")


print("loading big set")
os.chdir(r"C:/Users/Jason/OneDrive/TMU/Fall 25/DS8001/Project/ml-latest")
df = pd.read_csv("Master_large.csv")
print("done loading big set")
sizes = [100000, 390000, 680000, 970000, 1260000,
    1550000, 1840000, 2130000, 2420000, 2710000,
    3000000]
results = []
for n in sizes:
    print(f"\n=== Running on first {n:,} rows ===")
    df_sub = df.iloc[:n].copy()
    seed = random.randint(1, 10_000_000)
    rmse_val, time_taken, _, _,_ = evaluate_model(
        df_sub,
        predict_user_based,
        0.2,
        seed
    )
    print(f"user ({n:,} rows): RMSE={rmse_val:.4f}, time={time_taken:.4f}s")
    results.append({
        "size": n,
        "rmse": rmse_val,
        "time_seconds": time_taken
    })

results_df = pd.DataFrame(results)
os.chdir(r"C:/Users/Jason/OneDrive/TMU/Fall 25/DS8001/Project")
results_df.to_csv("user_results.csv", index=False)
print("\nSaved results to user_results.csv")


seed = random.randint(1, 10_000_000)
rmse_val, time_taken,_,_,_ = evaluate_model(df,predict_user_based,0.2,seed)
print(f"user Large: RMSE={rmse_val:.4f}, time={time_taken:.4f}s")

'''
# run with Master_small.csv
if __name__ == "__main__":
    df = pd.read_csv("Master_small.csv")[["userId", "movieId", "rating"]].copy()

    ub_rmse, ub_time, train_df, test_df, y_pred = evaluate_model(
        df,
        predict_fn=predict_user_based,
        test_ratio=0.2,
        seed=42
    )

    print(f"User-based Small: Test RMSE: {ub_rmse:.4f}")
    print(f"User-based Small: Total time (train+test): {ub_time:.3f} s")
'''


